- #### AMQP协议
```
指网络协议（应用层协议），高级消息队列协议
支持符合要求的客户端应用和消息中间件代理之间通信
```

- #### 消息代理(message brokers):
```
从发布者(publishers)或生产者(producers)接受消息，并根据既定的路由规则，
把接收到的消息发送给处理消息的消费者
```

- ####  AMQP模型
```
graph LR
Publish--publish-->Exchange
Exchange-- Routes--> Queue
Queue-- consumers-->Consumer
```

```
《1》发布者(pubishers):发布消息时可以给消息指定各种消息属性(message  meta-data)
 有些属性可能被消息代理(brokers)使用，其他属性完全不透明，它们只能被接受消息的应用使用   
《2》消息确认:当一个消息从队列中投递给消费者后(consumer),消费者会通知一下消息代理(broker),
    可以自动确认，也可以由消息的消费者手动确认
    当“消息确认”被启动时，消息代理不会将消息从队列中删除，直到收到消费者的“确认回执”(acknowledgement)
《3》死信队列:当消息无法被成功路由时，消息或许会被返回给发布者并被丢弃，
     或者，消息代理执行了延期操作，消息会被放入死信队列中
《4》队列、交换机和绑定统称为AMQP实体
```

- #### 交换机
```
用来发送消息的AMQP实体，交换机拿到一个消息后将它路由给一个或零个队列
具体使用那种路由算法由交换机类型和绑定的规则决定
```
- 交换机类型：

交换类型 | 默认名称
---|---
Direct(直连交换机) | amq.direct 
Fanout(扇形交换机) | amq.fanout 
Topic(主题交换机)  | amq.topic
Headers(头交换机)  | amq.match

```
交换机两个状态：持久(durable)、暂存(transient)
* 持久化的交换机会在消息代理(broker)重启后依然存在
* 暂存交换机需要消息代理再次上线后重新被声明
```

- #### 默认交换机(default exchange)
```
由消息代理预先声明好的名字为空字符串的直接交换机
每个新建队列(queue)都会自动绑定到默认交换机上，绑定的路由键(route key)和队列名称一致
默认交换机属于direct类型
```

- #### 直接交换机(direct exchange)
```
根据消息携带的路由键(route key)将消息投递到对应的队列上
用来处理消息的单播路由(unicast routing)
工作原理：
 * 将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键 
 * 当一个携带着路由键为R的消息被发送给直接交换机时，交换机把它投递给绑定值同样为R的队列
直接交换机通常用来循环发放任务给多个工作者(workers)
消息的负载是发生在消费者之间的，而不是队列之间
```

```
graph LR
image-- "routeKey=> archive" -->archive1
image-- "routeKey=> archive" -->archive2
image-- "routeKey=> crop" -->cropper
image-- "routeKey=> resize" -->resizer
```

- #### 扇型交换机(funout exchange)
```
将消息投递给绑定到它身上的所有队列，不理会绑定的路由键
用来处理消息的广播路由(broadcast routing)
工作原理：
如果N个队列绑定到某个扇型交换机，交换机会将消息的拷贝分别发送给所有N个队列
```

```
graph LR
Exchange-- route -->queue1
Exchange-- route -->queue2
Exchange-- route -->queue3
```

- #### 主题交换机(topic exchange)
```
通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由到一个或多个队列
用来实现消息的多播路由，实现各种发布/订阅及其变种
```

- #### 头交换机
```
消息的路由操作涉及到多个属性，使用消息头不路由键更容易表达
头交换机使用多个消息属性替代路由键建立路由规则
头交换机可以视为直连交换机的另一种表现形式，头交换机的头属性值可以是整数、字符串、哈希值或者字典
工作原理：
如果绑定到队列的头交换机使用了多个header，消息代理会根据每条消息（messge）的x-match参数判断需要部分匹配还是全部匹配
x-match为any时，消息头的任意一个值匹配成功
x-match为all时，消息头的所有值都匹配成功
```
- #### 队列
```
存储着即将被应用消费掉的消息，队列跟交换机共享某些属性，也有一些另外的属性
* Name
* Durable：消息代理重启后，队列依旧存在
* Exclusive：只被一个connection使用，当连接关闭后队列即被删除
* Auto—delete：当最后一个消费者退订时后被删除
* Arguments：一些消息代理用来完成类似TTL的某些额外功能
队列在声明后被使用
如果队列不存在，声明一个队列会创建它
如果声明的队列存在，并且属性完全相同，此次声明不会对队列产生任何影响
如果声明中的属性与队列有差异，会抛出406的异常
```

- #### 队列名称
```
队列的名称可以与应用（application）来命名，也可以由消息代理（broker）直接生成
以“amq.”开始的队列名称被预留做消息代理内部使用
```

- #### 队列状态
```
持久化队列（Durable queues）：会被存储在磁盘上，当消息代理（broker）重启时，依然存在
          只有经过持久化的消息才能被重新恢复
暂存队列（Transient queues）：消息存在于内存中
```

- #### 绑定
```
交换机将消息投递给队列所遵循的规则
绑定需要定义可选的路由属性给某些类型的交换机
交换机根据路由键从众多消息中选择某些消息，将其投递给绑定的队列
如果消息无法路由到队列，消息会被立即销毁或者返还给发布者，任何处理取决于发布者设置的消息属性
```
- #### 消费者
```
消息如果只是存储在队列里是没有用的。
只有被消费掉才能体现价值
消费者消费消息的途径有两种：
 * push：将消息推送给应用
 * pull：应用根据需要主动获取消息 
```


- #### 消息确认
```
消费者应用：用接受和处理消息，在处理消息时偶尔会失败或者会直接崩溃
消息确认机制（AMQP删除消息的时机）：
* 自动确认模式： 当消息代理将消息发送给应用后立即删除
* 显示确认模式：待应用发送一个确认回执后再删除消息
*** 如果一个消费者在尚未发送确认回执的情况下挂掉了，AMQP代理会将消息重新投递给另一个消费者
如果当时没有可用的消费者，消息代理会死等下一个注册到队列的消费者，然后再次尝试投递
```

- #### 循环调度&公平分发
```
循环分配：RabbitMQ安顺序将每条消息发送给下一个消费者
          平均每个消费者获得相同数量的消息
公平分发：可以通过BasicQos设置prefetchCount=1来告知RabbitMQ
          在未收到消息确认时，不再分发消息，以此确保消费端忙碌，不再分配任务
          如果所有的消费端都处于忙碌状态，队列可能被塞满，就需要更多的消费端，或采取其他策略
```

- #### 预取消息
```
多个消费者共享一个队列时，明确指定在收到下一个确认回执前每个消费者可以接受多少消息时很有用的。
在试图批量发布消息的时候可以起到简单的负载均衡和提高消息吞吐量的作用
```

- #### 消息属性和有效载荷
```
消息对象带有自己的属性，有些属性被AMQP代理使用，大多数由接受消息的应用解释器使用
```

属性名 | 说明
---|---
 content type | 内容类型 
 content encoding| 内容编码
 routing key|路由键
 delivery mode（persistent or not ）| 投递模式（持久化或非持久化）
 message priority| 消息优先级
 message publishing timestamp|消息发布时间戳
 expiration period| 消息有效期
 publisher application id| 发布应用的ID

```
有效载荷（Payload）：
* 消息实际携带的数据，被AMQP当作不透明的字节数据对待
* 消息代理不会检查或修改有效载荷
* 消息可以只包含属性而不携带有效载荷
消息的持久化：
完全取决于消息本身的持久化模式（persistence mode）
简单的将消息发送给一个持久化的交换机或路由器，并不能使消息具有持久化性质
消息的持久化方式会影响性能
```

- #### AMQP方法

交换机类，提供了操作交换机的有关方法:

方法 | 说明
---|---
exchange.declare| 客户端发起 “请求-Request”
exchange.declare-ok | 客户端发起 “请求-Request”
exchange.delete| 代理发起，回应Request “响应-Response”
exchange.delete-ok|代理发起，回应Request “响应-Response”

-  定义交换机
```
graph LR
consumer/publisher-- exchange.declare -->AmqpBroker
AmqpBroker -- exchange.declare-ok -->consumer/publisher
```

客户端通过excahnge.declare方法，要求代理声明一个新的交换机，
并且可以指定交换机名称、类型、是否持久化

- 定义队列
```
graph LR
consumer/publish-- queue.declare -->AmqpBroker
AmqpBroker -- queue.declare-ok-->consumer/publish
```

- #### 连接
```
AMQP连接通常是长连接
AMQP是一个使用TCP提供可靠投递的应用层协议
AMQP使用认证机制并且提供TLS（SSL）保护
当一个应用不再需要连接AMQP代理的时，需要优雅释放掉AMQP连接
```

- #### 通道
```
* 当应用和AMQP代理需要建立多个连接时，同时开启多个TCP连接是不合适的
* AMQP提供了通道（channels）来处理多连接，可以把通道理解为共享一个TCP连接的多个轻量级连接
* 在多线程、进程应用中，每个线程、进程开启一个通道，这些通道不能被线程、进程共享
* 通道之间的通讯是完全隔离的，每个AMQP方法都需要携带一个通道号，客户端就可以指定此方法为那个通道准的备
```
